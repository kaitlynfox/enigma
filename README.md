<h1>Enigma: Self-Assessment</h1>

<h2>Functionality</h2>
<p>Enigma Class with encrypt and decrypt methods successfully implemented.
Encrypt/decrypt command line interfaces successfully implemented.</p>

<p>To the best of my ability, I have implemented both the encrypt and
decrypt methods to successfully encrypt a message and then decrypt that same
message using the key and date initially used.</p>  



<h2>Object Oriented Programming</h2>
<p>Project is broken into logical components that are appropriately
encapsulated. No classes are unreasonably small or large, or contain
knowledge, information/behavior that they shouldnâ€™t know about. Student can
articulate the single responsibilities of the various components.</p>

<p>I have learned an incredible amount during this project. I struggled quite a
bit during the paired and group projects just trying to keep up and
contribute in anyway that I could, which was quite limited at the time.
Although I wasn't able to contribute as much as I would have liked during
those projects, being able to sit down without any distractions for an
extended amount of time really gave me the opportunity to break things and
really understand how and why things work together the way that they do. I
have improved my ability to break down larger components/methods into
helper methods (I had zero idea how to do this in the paired project and
going through most of the group project), and I have been able to refactor
more as I have become more familiar with coding in general. I am better at
identifying information that should be encapsulated but am still not as
proficient as I would like to be and is something that I am working on.</p>



<h2>Ruby Conventions and Mechanics</h2>
<p>Code is mostly properly indented, spaced, and lines are not excessively long.
Class, method, variable, and file names follow convention. Some enumerables,
data structures chosen are the most efficient tool for a given job, and
students can speak as to why those enumerables/data structures were chosen.
At least one hash is implemented in a way that makes logical sense.</p>

<p>Code is mostly properly indented and spaced. I do have a couple of lines
that are a bit longer than I'd like, but at this current moment, I have
found it extremely helpful to have names that might be a bit long but very
descriptive to help myself be able to follow and understand what it was
that I was intending to do and what I was intending to store. I do understand
that I will need to do better in this arena and that my variable and method
names can be shorter in length and still be descriptive. I have done my best
to use enumerables that are the most logical/efficient for the task at hand.
I have been holding back on using enumerables that I am not as comfortable
with but have tried to push myself out of my comfort zone and be a bit more
willing to try something I wouldn't normally default to (ex, placed offsets
into a hash).</p>



<h2>Test Driven Development</h2>
<p>Every method is tested at both the unit and integration level, and completely
verify expected behavior (i.e., if a single method does 3 things, all 3
things are explicitly tested). Obvious edge cases are addressed. git history
demonstrates students are writing tests before implementation code. Test
coverage metrics show coverage at 99% or greater.</p>

<p>I have been challenging myself to stick to the tests when running through
the project. This project has been very tricky when writing tests as the dates
and keys that can be autogenerated are either random or change based on the day.
I have run into issues where I thought that I had covered everything I needed
to, but there'd pop up some edge cases I didn't think about later on in
the project, so I'd try and go back to adjust for those changes. It is most
certainly not perfect, but I tried to cover as much as I could. Tests have been
a priority when doing this project, and I have done my best to write tests prior
to implementing code.</p>



<h2>Version Control</h2>
<p>A passing project will have a minimum of 30 commits, and uses a pull request
workflow that includes related and logical functionality.</p>

<p>I was able to reach the minimum of 30 commits and also created pull requests
to merge to main.</p>
